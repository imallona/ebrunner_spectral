---
title: "Spectral proof of concept"
author: "Robinsonlab @ UZH"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    toc: false
    toc_float: false
    code_folding: hide
    code_download: true
    number_sections: true
    df_print: kable
    theme: lumen
params:
    chromosome: ""
---

```{r}
suppressPackageStartupMessages({
    library(knitr)
    library('TmCalculator')
    ## library('entropy')
    ## library('rDNAse')
    library('msu')             # for Shannon's entropy
    library('data.table')
    library('Matrix')
    ## library('foreach')
    ## library('doParallel')
})
```

```{r}
opts_chunk$set(fig.width = 5,
               fig.height = 5,
               dev = 'png',
               cache = FALSE,
               include = TRUE,
               cache.lazy = FALSE,
               warning = TRUE,
               echo = TRUE,
               message = TRUE)
```

```{r}
WD <- '/home/imallona/giulia'
FILTERED_BED <- file.path(WD, 'safe_exons.bed')
KMER_LENGTH <- 25
NTHREADS <- 10
NUM_PROBES <- 3   ## probes per gene
OUTPUTS <- file.path(WD, 'probes')
```

```{r}

d <- list()
for (fn in list.files(OUTPUTS, pattern = "*tsv.gz")) {
    d[[basename(fn)]] <- datatable::fread(fn, header = TRUE)
}
```

TODO list

```
- Make sure the kmers don't overlap multiple genes (multifeature)
- Design a visualization approach
- Keep track of how many probes are filtered out at each step; document this within the report
- Parallelize (by gene) DONE by chromosome (?)
```

Shell design

<img src="figures/giulia1_bw.jpg" alt="shell" width="350"/>

Rmarkdown design

<img src="figures/giulia2_bw.jpg" alt="rscript" width="350"/>

```
Simplified algorithm for probe picking, based in continuous scoring:
- for each gene
-   for each probe
-     compute a compound score (to be refined)
-   sort by compound score
-   pick top probe
-   browse probes with decreasing scores to pick the best performing iff it does not overlap
       any previously picked ones; pick it, if satisfying the condition
-   repeat till the required num probes is fulfilled
```

The final score can be built on these individual scores:

```
- num transcripts covered
- GC content (boolean, being within a 'valid' range or not)
- Presence of homopolymers (4-mers) (boolean)
- Tm Wallace (not used for scoring yet)
- Tm SantaLucia (not used for scoring yet)
- `seldom_tx_score`: a measure of how 'unusual' the transcripts covered by a probe are.
```

Most of them are self-explanatory, except `seldom_tx_score`. This score is designed to favour probes which overlap to seldom/rare transcripts (as compared to the pool of other kmers).

To do so, `seldom_tx_score` sums the (decreasing) ranks of all transcripts scrutinized by the candidate probes, e.g. giving a `1` to the least represented one, a `2` to the next one, etc. 

The aim is to break any possible ties of probes covering the same (total) number of transcripts, favouring the less frequent transcripts. (The assumption is that other probes for the same gene will pick the most common transcripts anyway).

Example: random gene, with two transcripts only.

```
gene A transcripts:
                  Var1 Freq rank
1 ENSMUST1  295    2
2 ENSMUST2  531    1
```

So probes can be scored depending on how many transcripts do they cover: if overlapping

```
probe A: overlaps both: will have a score of 1+2 = 3
probe B: overlaps ENSMUST1 only: 2 (reward; few probes overlap ENSMUST1)
probe C: overlaps ENSMUST2 only: 1 (penalty; there are many probes overlapping ENSMUST2)
```

Another example: random gene, with three transcripts:

```
gene B transcripts:
                  Var1 Freq rank
1 ENSMUST1  795    1
2 ENSMUST2  531    2
3 ENSMUST3  100    3
```

And we're trying to score four probes:

```
probe      tx covered           seldom_tx_score
probe1     ENSMUST1             1
probe2     ENSMUST1,ENSMUST2    1+2=3
probe3     ENSMUST2,ENSMUST3    2+3=5
probe4     ENSMUST1,ENSMUST3    1+3=4
```

So in this case, in the absence of any other reason to score the probes differently, we would pick:
probe3, probe4, and probe2.

If only one transcript present, all kmers are assigned `seldom_tx_score = 1`.


Compound scoring. The current score favours (linearly) number of transcripts covered, seldom_tx_score, Shannon entropy, having a GC content in a safe range, and lacking homopolymers.

```
(1)    fd[[gene_id]]$num_transcripts +
(2)    fd[[gene_id]]$seldom_tx_score +
(3)    fd[[gene_id]]$shannon_entropy +
(4)    as.numeric(fd[[gene_id]]$valid_gc) + 
(5)    (as.numeric(fd[[gene_id]]$homopolymer) * -1)
```


# PoC {.tabset .tabset-fade .tabset-pills}

Browsing 10 genes. 


```{r}
## gtf here

gtf <- read.table(FILTERED_BED)
colnames(gtf) <- c('gtf_chr', 'gtf_start', 'gtf_end', 'gtf_id', 'gtf_feature', 'gtf_strand')

gtf <- cbind(gtf,
           strcapture(
               pattern = "ID.*exon:(.*);Parent.*gene_id=(.*);.*transcript_id=(.*);gene_type.*",
               x = gtf$gtf_id,
               proto = list(exon = character(),
                            gene_id = character(), transcript_id = character())))


```

```{r, results = 'asis'}

known <- aggregate(gtf$transcript_id,
                   list(gene = gtf$gene_id,
                        transcript = gtf$transcript_id),
                   FUN = function(x) length(unique(x)))


for (gene_id in head(names(fd), 10)){

    cat('## ', gene_id, '{.tabset .tabset-fade .tabset-pills} \n\n')
    
    cat('### Known transcripts \n\n')
    to_design <- known[known$gene == gene_id, ]
    print(knitr::kable(to_design, row.names = FALSE))
    cat('\n\n')
    
    cat('### Picked probes \n\n')

    designed <- fd[[gene_id]][fd[[gene_id]]$picked,]
    print(knitr::kable(designed, row.names = FALSE))

    cat('### Covered transcripts (percent) \n\n')

    to_design$covered <- to_design$transcript  %in%
        unlist(strsplit(designed$transcripts, split = ';'))

    print(sum(to_design$covered)/nrow(to_design) * 100)
    
    cat('\n\n')
}
    
```

# Overall stats

Genes provided:

```{r}
con <- file(FEATURES) 
(num_genes <- length(readLines(con)))
close(con)

```

Genes for which kmers were designed:

```{r}
print(length(unique(d$gene_id)))
```

Per gene: num transcripts in GTF, num transcripts for which kmers were designed (coverable due to the 300 bp limit), number of transcripts covered by probes.

Add total number of transcripts (real, from GTF?)

```{r}
known <- aggregate(gtf$transcript_id,
                   by=  list(gtf$gene_id),
                   FUN = function(x) length(unique(x)))

colnames(known) <- c('gene_id', 'num_coverable_transcripts')

fd <- do.call(rbind.data.frame,
                  lapply(fd, function(x) return(x[x$picked,])))

tmp <- merge(fd, known, by = 'gene_id', all.x = TRUE)

tmp <- tmp[order(tmp$num_coverable_transcripts),]

```

```{r fig.width = 12, fig.height = 6}
par(mfrow = c(2,2))
plot(x = 1:nrow(tmp),
     y = tmp$num_coverable_transcripts,
     pch = 3,
     ylim = c(0, max(tmp$num_coverable_transcripts)),
     xlab = 'gene (sorted by num transcripts)',
     ylab = 'num target transcripts per gene')
     col = 'black')

plot(x = 1:nrow(tmp),
     y = tmp$num_transcripts,
     ylim = c(0, max(tmp$num_coverable_transcripts)),
     ylab = 'num covered transcripts per gene',
     xlab = 'gene (sorted by num transcripts)',
     col = 'darkred',
     pch = 19,
     type = 'b')

## points(x = 1:nrow(tmp),
##        y = tmp$num_transcripts,
##        col = 'blue',
##        pch = 6,
##        type = 'b')

plot(x = 1:nrow(tmp),
     y = tmp$num_coverable_transcripts,
     ylim = c(min(tmp$num_transcripts - tmp$num_coverable_transcripts),
              max(tmp$num_coverable_transcripts)),
     pch = 3,
     xlab = 'gene (sorted by num transcripts)',
     ylab = 'num target transcripts per gene',
     col = 'black')

points(x = 1:nrow(tmp),
     y = tmp$num_transcripts - tmp$num_coverable_transcripts,
     ylim = c(min(tmp$num_transcripts - tmp$num_coverable_transcripts),
              max(tmp$num_coverable_transcripts)),
     ylab = 'num covered transcripts per gene',
     xlab = 'gene (sorted by num transcripts)',
     col = 'darkblue',
     pch = 19,
     type = 'b')

legend('topleft', legend = c("num target transcripts",
                             "num covered transcripts - num target transcripts"),
       col=c("black", "darkblue"), pch = c(3, 19),
       cex = 0.8)



plot(x = jitter(tmp$num_transcripts, 1),
     y = jitter(tmp$num_coverable_transcripts, 1),
     pch = 19,
     ylab = 'num target transcripts per gene (jitter)',
     xlab = 'num covered transcripts per gene (jitter)',
     col = rgb(0, 0, 255, max = 255, alpha = 125))
```



Average number probes per gene... it's three for all of them (?).

```{r}
summary(aggregate(tmp$kmer,
                  by=  list(tmp$gene_id),
                  FUN = function(x) length(x)))

```


# Session info

```{r}
devtools::session_info()
system('whoami')
system('uname -a')
```
