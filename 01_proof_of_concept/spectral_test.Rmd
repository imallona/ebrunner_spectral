---
title: "Spectral proof of concept"
author: "Robinsonlab @ UZH"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    code_download: true
    number_sections: true
    df_print: kable
    theme: lumen
---

```{r}
suppressPackageStartupMessages({
    library(knitr)
    library('TmCalculator')
    ## library('entropy')
    ## library('rDNAse')
    library('msu')
})
```

```{r}
opts_chunk$set(fig.width = 5,
               fig.height = 5,
               dev = 'png',
               cache = FALSE,
               include = TRUE,
               cache.lazy = FALSE,
               warning = TRUE,
               echo = TRUE,
               message = TRUE)
```

```{r}
WD <- '/home/imallona/giulia'
KMER_LENGTH <- 25
NTHREADS <- 10
MAPPING <- file.path(WD, 'mapping', sprintf('kmers_%s.uniques.gz', KMER_LENGTH))
FILTERED_BED <- file.path(WD, 'safe_exons.bed')

```


TODO list

```
- Make sure the kmers don't overlap multiple genes (multifeature)
- Design a visualization approach
- Keep track of how many probes are filtered out at each step; document this within the report
```

Shell design

<img src="figures/giulia1_bw.jpg" alt="shell" width="350"/>

Rmarkdown design

<img src="figures/giulia2_bw.jpg" alt="rscript" width="350"/>

```{r}
d <- read.table(MAPPING)
colnames(d) <- c('read', 'chr', 'start', 'match', 'NH', 'HI', 'NM', 'MD', 'AS', 'nM', 'kmer')

for (item in setdiff(colnames(d), c('read', 'chr', 'start', 'match', 'kmer'))){
    d[,item] <- as.numeric(gsub(paste0(item, ':i:|MD:Z:'), '', d[,item]))
}

```

```{r}
d <- cbind(d,
           strcapture(
               pattern = "exon_coord=(.*):([0-9]+)-([0-9]+)([-+]{1});(.*)_kmer.*",
               x = d$read,
               proto = list(sim_chr = character(),
                            sim_start = numeric(),
                            sim_end = numeric(),
                            sim_strand = character(),
                            exon = character())))
```

First consistency check, are the mapped reads mapping into a region matching the one was simulated? For that we check the chromosome matches, and the mapping site is at less than 1 Mbp from the simulated site.

```{r}
d$simulation_locus_match <- FALSE
d$simulation_locus_match <- d$sim_chr == d$chr & (abs(d$start - d$sim_start) < 1e6)
stopifnot(all(d$simulation_locus_match))
print('Check passed')
```

Then, annotate with the gene, transcript and exon names/coordinates, to check for even spacing, and feature covering.

```{r}
gtf <- read.table(FILTERED_BED)
colnames(gtf) <- c('gtf_chr', 'gtf_start', 'gtf_end', 'gtf_id', 'gtf_feature', 'gtf_strand')

gtf <- cbind(gtf,
           strcapture(
               pattern = "ID.*exon:(.*);Parent.*gene_id=(.*);.*transcript_id=(.*);gene_type.*",
               x = gtf$gtf_id,
               proto = list(exon = character(),
                            gene_id = character(), transcript_id = character())))
```

```{r}
d <- merge(d, gtf, by.x = 'exon', by.y = 'exon', all.x = TRUE)
d <- d[,setdiff(colnames(d), c('gtf_id', 'read'))]
```

<!-- ```{r} -->
<!-- aggregate(gtf$transcript_id~gtf$gene_id, gtf, function(x) length(unique(x))) -->
<!-- ``` -->

<!-- How many kmers have we designed per gene? -->

<!-- ```{r} -->
<!-- ## these are how many kmers per gene are there -->
<!-- aggregate(d$kmer~d$gene, d, function(x) length(unique(x))) -->
<!-- ``` -->

<!-- Are there kmers that span more than a single transcript (within the same gene)? -->

<!-- ```{r} -->
<!-- agg <- aggregate(d$kmer, list(kmer = d$kmer, -->
<!--                             chr = d$chr, -->
<!--                             start = d$start, -->
<!--                             gene_id = d$gene_id), -->
<!--                  FUN = function(x) length(x)) -->
<!-- colnames(agg)[5] <- 'tx_covered' -->
<!-- agg <- agg[order(agg$tx_covered, agg$gene, decreasing = TRUE),] -->

<!-- head(agg) -->
<!-- ``` -->

# Tm, GC annotation

```
TODO: Decide which Tm estimation method to use
```

```{r}

d$gc <- sapply(d$kmer, function(x) TmCalculator::GC(x))

d$Tm_NN <- sapply(d$kmer,
                  function(x) TmCalculator::Tm_NN(x,
                                                  ambiguous = FALSE, comSeq = NULL,
                                                  shift = 0,
                                                  nn_table = "DNA_NN4",
                                                  tmm_table = "DNA_TMM1",
                                                  imm_table = "DNA_IMM1",
                                                  de_table = "DNA_DE1",
                                                  dnac1 = 25,
                                                  dnac2 = 25,
                                                  selfcomp = FALSE,
                                                  Na = 50, K = 0, Tris = 0, Mg = 0,
                                                  dNTPs = 0, saltcorr = 5))

summary(d$tmNN)
```

Homopolymer annotation: flag any probe with more than 5 consecutive repeated nts.

```{r}
regex <- '(A){5,}|(T){5,}|(C){5,}|(G){5,}'
d$homopolymer <- grepl(regex, d$kmer, ignore.case = TRUE)
```

Sequence complexity (Shannon's entropy on 2-mers)

```{r}
## length of the substrinb
k <- 2

d$shannon_entropy <- sapply(d$kmer,
                            function(x) msu::shannon_entropy(factor(substring(x, 1:(nchar(x)-k+1), k:nchar(x)))))

```

Self complementarity (?)

```{r}
print('todo')
```

# PoC {.tabset .tabset-fade .tabset-pills}


In our test dataset, we filtered out 300 bp from the most 'upstream' (strand-specific) gene feature (start coordinate). (@todo: refine/clarify if this should be transcript instead.).

```{r, results = 'asis'}

known <- aggregate(gtf$transcript_id,
                   list(gene = gtf$gene_id,
                        transcript = gtf$transcript_id),
                   FUN = function(x) length(unique(x)))

agg <- aggregate(d$kmer, list(kmer = d$kmer,
                             chr = d$chr,
                             start = d$start,
                             gene_id = d$gene_id),
                  FUN = function(x) length(x))

colnames(agg)[5] <- 'tx_covered'

maxes <-  aggregate(tx_covered ~ gene_id, data=agg[,c('tx_covered', 'gene_id')], max)

maxes$compound <- paste(maxes$gene_id, maxes$tx_covered)
agg$compound <- paste(agg$gene_id, agg$tx_covered)
agg <- agg[agg$compound %in% maxes$compound,]

designed <- agg[!duplicated(agg$compound),]
rm(agg, maxes)

for (i in 1:nrow(designed)){
    gene <- designed$gene_id[i]

    cat('## ', gene, '{.tabset .tabset-fade .tabset-pills} \n\n')
    
    cat('### Known transcripts \n\n')
    print(knitr::kable(known[known$gene == gene, ],
                       row.names = FALSE))
    cat('\n\n')
    
    cat('### Random probe matching the highest number of transcripts \n\n')
    print(designed$kmer[i])
    
    print(knitr::kable(d[d$kmer == designed$kmer[i],],
                       row.names = FALSE))

    cat('\n\n')
}
    
```

Thoughts: if none of the probes match multiple transcripts, then better ensure one probe per transcript is designed (?).

# Scoring probes

Algorithm to pick N probes per gene that are: overlapping the highest number of transcripts as possible, and evenly spaced

```{r}
print('todo')
```

# Session info

```{r}
devtools::session_info()
system('whoami')
system('uname -a')
```
